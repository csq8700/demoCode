function Get-XmlSubNodesToHashtable {
    <#
    .SYNOPSIS
        获取XML指定节点下的所有子元素和值，返回哈希表
    
    .DESCRIPTION
        通过XPath定位到指定节点，然后递归获取该节点下的所有子元素（包括嵌套子节点）
        返回的哈希表只包含指定节点下的元素，不包含该节点本身
    
    .PARAMETER XmlContent
        XML字符串或XmlDocument对象
    
    .PARAMETER XPath
        用于定位父节点的XPath表达式
    
    .PARAMETER IncludeAttributes
        是否包含元素的属性
    
    .PARAMETER FlattenArrays
        当只有一个元素时，是否不创建数组
    
    .EXAMPLE
        $xml = [xml]"<root><person><name>John</name><age>30</age><hobbies><hobby>Reading</hobby></hobbies></person></root>"
        $result = Get-XmlSubNodesToHashtable -XmlContent $xml -XPath "//person"
        # 返回: @{name="John"; age="30"; hobbies=@{hobby="Reading"}}
    
    .EXAMPLE
        $xml = [xml]"<config><database><server>localhost</server><port>1433</port></database></config>"
        $result = Get-XmlSubNodesToHashtable -XmlContent $xml -XPath "/config/database"
        # 返回: @{server="localhost"; port="1433"}
    
    .EXAMPLE
        $xml = [xml]"<books><book id='1'><title>Book1</title></book></books>"
        $result = Get-XmlSubNodesToHashtable -XmlContent $xml -XPath "//book" -IncludeAttributes
        # 返回: @{title="Book1"; @id="1"}
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [object]$XmlContent,
        
        [Parameter(Mandatory = $true, Position = 1)]
        [string]$XPath,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeAttributes = $false,
        
        [Parameter(Mandatory = $false)]
        [switch]$FlattenArrays = $false
    )
    
    # 1. 处理输入，转换为XmlDocument
    $xmlDoc = $null
    if ($XmlContent -is [string]) {
        try {
            $xmlDoc = [xml]$XmlContent
        } catch {
            throw "无法解析XML字符串: $_"
        }
    } elseif ($XmlContent -is [xml]) {
        $xmlDoc = $XmlContent
    } else {
        throw "输入必须是XML字符串或XmlDocument对象"
    }
    
    # 2. 使用XPath查找节点
    Write-Verbose "使用XPath查找节点: $XPath"
    $selectedNodes = $xmlDoc.SelectNodes($XPath)
    
    if ($null -eq $selectedNodes -or $selectedNodes.Count -eq 0) {
        Write-Warning "未找到匹配的节点: $XPath"
        return @{}
    }
    
    # 3. 如果有多个匹配节点，返回数组
    if ($selectedNodes.Count -gt 1) {
        Write-Verbose "找到 $($selectedNodes.Count) 个匹配的节点"
        $results = @()
        
        foreach ($node in $selectedNodes) {
            $nodeResult = Convert-XmlNodeToHashtable -XmlNode $node `
                -IncludeAttributes:$IncludeAttributes `
                -FlattenArrays:$FlattenArrays `
                -ProcessCurrentNode:$false  # 不处理当前节点本身
            $results += $nodeResult
        }
        
        return $results
    }
    
    # 4. 单个节点，直接转换
    Write-Verbose "找到 1 个匹配的节点"
    $node = $selectedNodes[0]
    
    return Convert-XmlNodeToHashtable -XmlNode $node `
        -IncludeAttributes:$IncludeAttributes `
        -FlattenArrays:$FlattenArrays `
        -ProcessCurrentNode:$false  # 不处理当前节点本身
}

function Convert-XmlNodeToHashtable {
    <#
    .SYNOPSIS
        将XML节点及其子节点转换为哈希表（内部函数）
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [System.Xml.XmlNode]$XmlNode,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeAttributes = $false,
        
        [Parameter(Mandatory = $false)]
        [switch]$FlattenArrays = $false,
        
        [Parameter(Mandatory = $false)]
        [bool]$ProcessCurrentNode = $true
    )
    
    # 如果不处理当前节点，直接处理子节点
    if (-not $ProcessCurrentNode) {
        return Process-XmlChildNodes -ParentNode $XmlNode `
            -IncludeAttributes:$IncludeAttributes `
            -FlattenArrays:$FlattenArrays
    }
    
    # 处理当前节点
    $result = @{}
    
    # 添加属性（如果需要）
    if ($IncludeAttributes -and $XmlNode.Attributes.Count -gt 0) {
        foreach ($attr in $XmlNode.Attributes) {
            $result["@$($attr.Name)"] = $attr.Value
        }
    }
    
    # 处理子节点
    $childResult = Process-XmlChildNodes -ParentNode $XmlNode `
        -IncludeAttributes:$IncludeAttributes `
        -FlattenArrays:$FlattenArrays
    
    # 合并结果
    foreach ($key in $childResult.Keys) {
        $result[$key] = $childResult[$key]
    }
    
    # 如果没有子元素，只有文本内容
    if ($result.Count -eq 0 -and $XmlNode.InnerText.Trim() -ne "") {
        return $XmlNode.InnerText.Trim()
    }
    
    return $result
}

function Process-XmlChildNodes {
    <#
    .SYNOPSIS
        处理XML节点的所有子节点（内部函数）
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [System.Xml.XmlNode]$ParentNode,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeAttributes = $false,
        
        [Parameter(Mandatory = $false)]
        [switch]$FlattenArrays = $false
    )
    
    $result = @{}
    
    # 获取所有子元素节点
    $childElements = $ParentNode.ChildNodes | Where-Object { $_.NodeType -eq "Element" }
    
    if ($childElements.Count -eq 0) {
        # 没有子元素，只有文本内容
        $textContent = $ParentNode.InnerText.Trim()
        if ($textContent -ne "") {
            # 返回文本值（但这里通常不会执行，因为由调用者决定）
            return $textContent
        }
        return $result
    }
    
    # 按节点名分组
    $groupedElements = $childElements | Group-Object Name
    
    foreach ($group in $groupedElements) {
        $nodeName = $group.Name
        
        if ($group.Count -eq 1) {
            # 单个节点
            $childNode = $group.Group[0]
            
            # 检查子节点是否还有子元素
            $hasChildElements = $childNode.ChildNodes | Where-Object { $_.NodeType -eq "Element" } | Select-Object -First 1
            
            if ($null -ne $hasChildElements) {
                # 有子元素，递归处理
                $result[$nodeName] = Convert-XmlNodeToHashtable -XmlNode $childNode `
                    -IncludeAttributes:$IncludeAttributes `
                    -FlattenArrays:$FlattenArrays `
                    -ProcessCurrentNode:$true
            } else {
                # 只有文本内容
                $textValue = $childNode.InnerText.Trim()
                if ($textValue -eq "" -and $childNode.HasChildNodes) {
                    # 可能是CDATA或混合内容
                    $textValue = $childNode.InnerText
                }
                $result[$nodeName] = $textValue
            }
        } else {
            # 多个同名节点 - 创建数组
            $arrayResult = @()
            
            foreach ($childNode in $group.Group) {
                # 检查子节点是否还有子元素
                $hasChildElements = $childNode.ChildNodes | Where-Object { $_.NodeType -eq "Element" } | Select-Object -First 1
                
                if ($null -ne $hasChildElements) {
                    # 有子元素，递归处理
                    $arrayResult += Convert-XmlNodeToHashtable -XmlNode $childNode `
                        -IncludeAttributes:$IncludeAttributes `
                        -FlattenArrays:$FlattenArrays `
                        -ProcessCurrentNode:$true
                } else {
                    # 只有文本内容
                    $textValue = $childNode.InnerText.Trim()
                    if ($textValue -eq "" -and $childNode.HasChildNodes) {
                        $textValue = $childNode.InnerText
                    }
                    $arrayResult += $textValue
                }
            }
            
            # 如果只有一个元素且FlattenArrays为true，则不创建数组
            if ($FlattenArrays -and $arrayResult.Count -eq 1) {
                $result[$nodeName] = $arrayResult[0]
            } else {
                $result[$nodeName] = $arrayResult
            }
        }
    }
    
    return $result
}

function Get-XmlNodeListToHashtable {
    <#
    .SYNOPSIS
        将XmlNodeList转换为哈希表数组
    
    .DESCRIPTION
        专门处理XmlNodeList对象，返回每个节点的哈希表数组
    
    .PARAMETER XmlNodeList
        XmlNodeList对象（通过SelectNodes获取）
    
    .EXAMPLE
        $xml = [xml]"<root><item><name>A</name></item><item><name>B</name></item></root>"
        $nodeList = $xml.SelectNodes("//item")
        $result = Get-XmlNodeListToHashtable -XmlNodeList $nodeList
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [System.Xml.XmlNodeList]$XmlNodeList,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeAttributes = $false
    )
    
    $results = @()
    
    foreach ($node in $XmlNodeList) {
        $nodeHash = Convert-XmlNodeToHashtable -XmlNode $node `
            -IncludeAttributes:$IncludeAttributes `
            -ProcessCurrentNode:$false
        $results += $nodeHash
    }
    
    return $results
}

# 使用示例函数
function Test-XmlSubNodesFunction {
    Write-Host "=== XML子节点提取测试 ===" -ForegroundColor Cyan
    
    # 示例1: 基本嵌套结构
    $xml1 = [xml]@"
<root>
    <person>
        <name>John Doe</name>
        <age>30</age>
        <contact>
            <email>john@example.com</email>
            <phone>123-456-7890</phone>
            <address>
                <street>123 Main St</street>
                <city>New York</city>
            </address>
        </contact>
        <skills>
            <skill>PowerShell</skill>
            <skill>C#</skill>
            <skill>SQL</skill>
        </skills>
    </person>
</root>
"@

    Write-Host "`n示例1: 获取person节点下的所有子元素" -ForegroundColor Green
    $result1 = Get-XmlSubNodesToHashtable -XmlContent $xml1 -XPath "//person" -Verbose
    $result1 | ConvertTo-Json -Depth 10 | Write-Host -ForegroundColor Yellow
    
    # 示例2: 多个相同节点
    $xml2 = [xml]@"
<employees>
    <employee id="101">
        <name>Alice</name>
        <department>IT</department>
        <salary>5000</salary>
    </employee>
    <employee id="102">
        <name>Bob</name>
        <department>HR</department>
        <salary>4500</salary>
    </employee>
    <employee id="103">
        <name>Charlie</name>
        <department>Finance</department>
        <salary>6000</salary>
    </employee>
</employees>
"@

    Write-Host "`n示例2: 获取所有employee节点（返回数组）" -ForegroundColor Green
    $result2 = Get-XmlSubNodesToHashtable -XmlContent $xml2 -XPath "//employee" -IncludeAttributes -Verbose
    $result2 | ConvertTo-Json -Depth 10 | Write-Host -ForegroundColor Yellow
    
    # 示例3: 使用XmlNodeList
    Write-Host "`n示例3: 使用XmlNodeList直接处理" -ForegroundColor Green
    $nodeList = $xml2.SelectNodes("//employee")
    $result3 = Get-XmlNodeListToHashtable -XmlNodeList $nodeList -IncludeAttributes
    $result3 | ConvertTo-Json -Depth 10 | Write-Host -ForegroundColor Yellow
    
    # 示例4: 复杂XML结构
    $xml4 = [xml]@"
<configuration>
    <appSettings>
        <add key="Server" value="localhost" />
        <add key="Port" value="8080" />
        <add key="Timeout" value="30" />
    </appSettings>
    <connectionStrings>
        <add name="Default" connectionString="Data Source=.;Initial Catalog=Test;Integrated Security=True" />
        <add name="Backup" connectionString="Data Source=backup;Initial Catalog=Backup;User ID=admin" />
    </connectionStrings>
</configuration>
"@

    Write-Host "`n示例4: 获取appSettings下的add节点" -ForegroundColor Green
    $result4 = Get-XmlSubNodesToHashtable -XmlContent $xml4 -XPath "//appSettings" -Verbose
    $result4 | ConvertTo-Json -Depth 10 | Write-Host -ForegroundColor Yellow
    
    Write-Host "`n示例4: 获取connectionStrings下的add节点" -ForegroundColor Green
    $result5 = Get-XmlSubNodesToHashtable -XmlContent $xml4 -XPath "//connectionStrings" -Verbose
    $result5 | ConvertTo-Json -Depth 10 | Write-Host -ForegroundColor Yellow
    
    # 示例5: 文件操作示例
    Write-Host "`n示例5: 从文件读取XML" -ForegroundColor Green
    # 创建临时XML文件
    $tempFile = [System.IO.Path]::GetTempFileName() + ".xml"
    @"
<?xml version="1.0" encoding="UTF-8"?>
<library>
    <book category="fiction">
        <title>The Great Gatsby</title>
        <author>F. Scott Fitzgerald</author>
        <year>1925</year>
        <price>10.99</price>
    </book>
    <book category="non-fiction">
        <title>PowerShell in Action</title>
        <author>Bruce Payette</author>
        <year>2011</year>
        <price>49.99</price>
    </book>
</library>
"@ | Out-File -FilePath $tempFile -Encoding UTF8
    
    try {
        $xmlFromFile = [xml](Get-Content $tempFile)
        $fileResult = Get-XmlSubNodesToHashtable -XmlContent $xmlFromFile -XPath "//library" -IncludeAttributes
        Write-Host "从文件读取的结果:" -ForegroundColor Green
        $fileResult | ConvertTo-Json -Depth 10 | Write-Host -ForegroundColor Yellow
    }
    finally {
        Remove-Item $tempFile -ErrorAction SilentlyContinue
    }
    
    Write-Host "`n=== 测试完成 ===" -ForegroundColor Cyan
}

# 导出函数
Export-ModuleMember -Function Get-XmlSubNodesToHashtable, Get-XmlNodeListToHashtable

# 运行测试
Test-XmlSubNodesFunction
